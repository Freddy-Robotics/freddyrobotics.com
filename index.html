<html>
    <head>
        <!-- Primary Meta Tags -->
        <title>Freddy Robotics - See what your kids are eating</title>
        <meta name="title" content="Freddy Robotics - See what your kids are eating" />
        <meta name="description" content="One-man team based in Ventura, CA, building fun robots to improve childhood nutrition. Founded in July 2024 by Jim Bisenius with support from Bill Bisenius." />

        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://freddyrobotics.com/" />
        <meta property="og:title" content="Freddy Robotics - See what your kids are eating" />
        <meta property="og:description" content="One-man team based in Ventura, CA, building fun robots to improve childhood nutrition. Founded in July 2024 by Jim Bisenius with support from Bill Bisenius." />
        <meta property="og:image" content="https://freddyrobotics.com/og-image.png" />

        <!-- Twitter -->
        <meta property="twitter:card" content="summary_large_image" />
        <meta property="twitter:url" content="https://freddyrobotics.com/" />
        <meta property="twitter:title" content="Freddy Robotics - See what your kids are eating" />
        <meta property="twitter:description" content="One-man team based in Ventura, CA, building fun robots to improve childhood nutrition. Founded in July 2024 by Jim Bisenius with support from Bill Bisenius." />
        <meta property="twitter:image" content="https://freddyrobotics.com/og-image.png" />

        <!-- Favicon -->
        <link rel="icon" type="image/x-icon" href="/favicon.ico">       
    </head>
    <body style="
        line-height: 1.4;
        font-size: 16px;
        padding: 0 25px;
        margin: 25 auto;
        max-width: 650px;
    ">
    <div style="
        max-width: 38em;
        margin: 15 auto;
        margin-top: 70px;
    ">
        <h2>Freddy Robotics - See what your kids are eating</h2>
        <ul>
            <li>One-man team based in Ventura, CA, building fun robots to improve childhood nutrition</li>
            <li>Founded in July 2024 by <a target="_blank" href="https://github.com/jimmybisenius">Jim Bisenius</a> with support from Bill Bisenius</li>
        </ul>
        <i>Our first product, the <b>Freddy Dog:</b></i>
        <br/><br/>
        <img style="width: 100%; height: auto; border-radius: 3px;" src="./freddy-dog-v2.png"/>
        <ul>
            <li>A small, robot dog that encourages children ages 3-10 to track meals and eat healthy</li>
            <li>Unlock tricks & games by adding your meals. Get multipliers for eating healthy!</li>
            <li>Sends parents notifications when their children are near possible allergens</li>
            <li>Parents can see their kid's diet in-app, and set nutrition goals as-needed</li>
            <li>Provide detailed nutritional records for sports, healthcare, and legal conflicts</li>
        </ul>
        <i><b>Freddy Dog</b></i> will be available first as a DIY build-kit, ideal for a parent and child, late this August.<br/>
        This build kit takes approximately 30 minutes, teaches your child about AI, hardware, and software, and no coding or wiring experience is neccessary. <i>Estimated price: $199-299</i>
        <br/><i>(Includes access to our weekly project update and livestream session)</i>
        <br/><br/>
        <hr/>
        <h3>Frequently asked questions:</h3>
        <b>How does Freddy work?</b>
        <p>Freddy uses it's camera to constantly scan it's surroundings, identifying objects and faces using Google's Tensorflow AI locally. Once Tensorflow has recognized a face in the image-frame alongside a meal, it will blur any faces within the image and send it to the GPT-4o-mini API for processing, which is able to estimate your foods nutritional details and grade your meal's overall nutrition score (A-F) with reasnonable accuracy. These results are then viewable in our mobile-app for parents.</p>
        <b>How do allergen notifications work?</b>
        <p>Parents add a list of potential allergens during setup, and sets a priority level. When Freddy's camera detects any of of these potential allergens in camera using GPT-4o, we'll immediately send a notification to the attached parent, alongside any other contact information listed (your nanny, daycare facility, etc.). Parents can also adjust the confidence level, or likelyhood to trigger a false alarm. </p>
        <b>How do I contact you?</b>
        <p>Reach out to Jim at <a href="mailto:jim@freddyrobotics.com">jim@freddyrobotics.com</a> or <a href="tel:+19842698841">984-269-8841</a></p>
        
        <h3>Take a break and play Candy Match!</h3>
        <canvas id="gameCanvas" width="400" height="400" style="background: #f0f0f0; border-radius: 3px;"></canvas>
        <p><small>Click and drag candies to match 3 or more!</small></p>
        
        <script>
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            const GRID_SIZE = 8;
            const CELL_SIZE = canvas.width / GRID_SIZE;
            const COLORS = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
            
            let grid = [];
            let selectedCandy = null;
            let draggedCandy = null;
            
            // Initialize grid
            function initGrid() {
                for(let i = 0; i < GRID_SIZE; i++) {
                    grid[i] = [];
                    for(let j = 0; j < GRID_SIZE; j++) {
                        grid[i][j] = {
                            color: COLORS[Math.floor(Math.random() * COLORS.length)],
                            x: i,
                            y: j,
                            targetY: j
                        };
                    }
                }
            }
            
            // Draw a candy
            function drawCandy(candy) {
                const x = candy.x * CELL_SIZE + CELL_SIZE/2;
                const y = candy.y * CELL_SIZE + CELL_SIZE/2;
                ctx.fillStyle = candy.color;
                ctx.beginPath();
                ctx.arc(x, y, CELL_SIZE/2 - 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Check for matches
            function checkMatches() {
                let matches = new Set();
                
                // Check horizontal matches
                for(let y = 0; y < GRID_SIZE; y++) {
                    for(let x = 0; x < GRID_SIZE-2; x++) {
                        if(grid[x][y].color === grid[x+1][y].color && 
                           grid[x][y].color === grid[x+2][y].color) {
                            matches.add(`${x},${y}`);
                            matches.add(`${x+1},${y}`);
                            matches.add(`${x+2},${y}`);
                        }
                    }
                }
                
                // Check vertical matches
                for(let x = 0; x < GRID_SIZE; x++) {
                    for(let y = 0; y < GRID_SIZE-2; y++) {
                        if(grid[x][y].color === grid[x][y+1].color && 
                           grid[x][y].color === grid[x][y+2].color) {
                            matches.add(`${x},${y}`);
                            matches.add(`${x},${y+1}`);
                            matches.add(`${x},${y+2}`);
                        }
                    }
                }
                
                // Remove matched candies and create new ones
                matches.forEach(pos => {
                    const [x, y] = pos.split(',').map(Number);
                    grid[x][y].color = COLORS[Math.floor(Math.random() * COLORS.length)];
                });
                
                return matches.size > 0;
            }
            
            // Handle mouse events
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
                
                if(x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                    selectedCandy = grid[x][y];
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if(selectedCandy) {
                    const rect = canvas.getBoundingClientRect();
                    const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
                    const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
                    
                    if(x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                        draggedCandy = grid[x][y];
                    }
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                if(selectedCandy && draggedCandy && 
                   Math.abs(selectedCandy.x - draggedCandy.x) + 
                   Math.abs(selectedCandy.y - draggedCandy.y) === 1) {
                    // Swap candies
                    const tempColor = selectedCandy.color;
                    selectedCandy.color = draggedCandy.color;
                    draggedCandy.color = tempColor;
                    
                    // If no match, swap back
                    if(!checkMatches()) {
                        const tempColor = selectedCandy.color;
                        selectedCandy.color = draggedCandy.color;
                        draggedCandy.color = tempColor;
                    }
                }
                selectedCandy = null;
                draggedCandy = null;
            });
            
            function update() {
                checkMatches();
            }
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                for(let i = 0; i < GRID_SIZE; i++) {
                    for(let j = 0; j < GRID_SIZE; j++) {
                        drawCandy(grid[i][j]);
                    }
                }
                
                // Highlight selected candy
                if(selectedCandy) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(
                        selectedCandy.x * CELL_SIZE, 
                        selectedCandy.y * CELL_SIZE, 
                        CELL_SIZE, 
                        CELL_SIZE
                    );
                }
            }
            
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
            
            initGrid();
            gameLoop();
        </script>
        
        <br/>
        <p>Â© Copyright 2024 Freddy Robotics Company. All rights reserved.</p>
        <a href="/updates">Updates</a>
        <br/><br/>
        
    </div>
    </body>
</html>